<!doctype html>
<html lang="en">
	<head>
		<title>Final Project</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/keys.js"></script>
		<script src='js/THREEx.KeyboardState.js'></script>

		<script>
		var scene, camera, renderer, controls, container;
		var car, c1, c2, throughStart, throughC1, throughC2, throughFinish;
		var clock = new THREE.Clock();
		var keyboard = new THREEx.KeyboardState();
		var collidableMeshList = [];
		var checkpoint1 = [];
		var checkpoint2 = [];
		var finishline = [];
		
		init();
		animate();
			 
		function init() {
			scene = new THREE.Scene();
			var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
			var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH/SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			scene.add(camera);
			camera.lookAt(scene.position);
			
			//Renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
			//lighting
			//var light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
			var light = new THREE.DirectionalLight(0xffffff, 1.75);
			light.position.set(-500, 500, -500);
			//light.position.set(0, 5, 0);
			scene.add(light);
			var aLight = new THREE.AmbientLight( 0x404040, 1 );
			scene.add( aLight );
			var sphereSize = 1;
			var pointLightHelper = new THREE.PointLightHelper( light, sphereSize );
			scene.add( pointLightHelper );
			
			// load a texture, set wrap mode to repeat
			var texture = new THREE.TextureLoader().load( "textures/racetrackEdit.png" );
			var textureSky = new THREE.TextureLoader().load("textures/cloudy.jpg");
			var textureCone = new THREE.TextureLoader().load("textures/cone.jpg");
			var textureWalls = new THREE.TextureLoader().load("textures/wall.jpg");
						
			//Skybox
			var skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
			var skyBoxMaterial = new THREE.MeshBasicMaterial({map: textureSky, side: THREE.BackSide});
			var sky = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
			scene.add(sky);
			
			//Plane Geometry
			var geometry = new THREE.PlaneGeometry( 5000, 5000, 10, 10);
			var material = new THREE.MeshPhongMaterial( { map: texture, side: THREE.DoubleSide } );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.y = -0.5;
			plane.rotation.x = Math.PI/2;
			scene.add( plane );	
			
			//east wall
			for(i = -26; i <26; i++){
			  var wallEastGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallEastMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallEast = new THREE.Mesh(wallEastGeometry, wallEastMaterial);
			   wallEast.position.set(5000/2, 7, i *100);
			  wallEast.rotation.y = Math.PI/2;
			  scene.add(wallEast);
			  collidableMeshList.push(wallEast);
			}
			
			//west wall
			for(i = -26; i <26; i++){
			  var wallWestGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallWestMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallWest = new THREE.Mesh(wallWestGeometry, wallWestMaterial);
			   wallWest.position.set(-5000/2, 7, i *100);
			  wallWest.rotation.y = Math.PI/2;
			  collidableMeshList.push(wallWest);
			  scene.add(wallWest);
			}
			
			//North wall
			for(i = -26; i <26; i++){
			  var wallNorthGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallNorthMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallNorth = new THREE.Mesh(wallNorthGeometry, wallNorthMaterial);
			   wallNorth.position.set(i *100, 7, -5000/2);
			   	collidableMeshList.push(wallNorth);
			  scene.add(wallNorth);
			}
			//North wall
			for(i = -26; i <26; i++){
			  var wallSouthGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallSouthMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallSouth = new THREE.Mesh(wallSouthGeometry, wallSouthMaterial);
			   wallSouth.position.set(i *100, 7, 5000/2);
			   collidableMeshList.push(wallSouth);
			  scene.add(wallSouth);
			
			
			//middle wall
			  var wallGeometry = new THREE.CubeGeometry(1800, 10, 5);
			  var wallMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wall = new THREE.Mesh(wallGeometry, wallSouthMaterial);
			   wall.position.set(-1600, 7, 80);
			   wall.rotation.y = Math.PI/2.1;
			   collidableMeshList.push(wall);
			  scene.add(wall);
			}
			
			//invisible finish line
			var finishGeometry = new THREE.CubeGeometry(550, 100, 50);
			var finishmaterial = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
			var finish =  new THREE.Mesh(finishGeometry, finishmaterial);
			finish.position.x = -1850;
			finish.position.z = 20;
			finish.material.transparent = true;
			finish.material.opacity = 0;
			scene.add(finish);
			finishline.push(finish);
			
			//invisible checkpoint1 line
			var checkpoint1Geometry = new THREE.CubeGeometry(550, 100, 50);
			var checkpoint1material = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
			c1 =  new THREE.Mesh(checkpoint1Geometry, checkpoint1material);
			c1.position.x = 800;
			c1.position.z = -1000;
			c1.material.transparent = true;
			c1.material.opacity = 0;
			scene.add(c1);
			checkpoint1.push(c1);
			
			//invisible checkpoint2
			var checkpoint2Geometry = new THREE.CubeGeometry(550, 100, 50);
			var checkpoint2material = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
			var c2 =  new THREE.Mesh(checkpoint2Geometry, checkpoint2material);
			c2.position.x = 800;
			c2.position.z = 2000;
			c2.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.PI/2);
			c2.material.transparent = true;
			c2.material.opacity = 0;
			scene.add(c2);
			checkpoint2.push(c2);
			
			//car/cube
			 var cubeMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
			 var cubeGeometry = new THREE.CubeGeometry(27, 27, 42, 1, 1, 1, cubeMaterial);
			 cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			 cube.position.set(0, 7, 0);
			 cube.material.transparent = true;
			 cube.material.opacity = 0.0;
			 scene.add(cube);
			 cube.position.x = -2000;
			 cube.position.z = 100;
			//cones
			for(i = 0; i < 500; i++) {
			    // var coneMaterial = new THREE.MeshPhongMaterial({color: 0xff6600, side: THREE.DoubleSide});
			    var coneMaterial = new THREE.MeshPhongMaterial({map: textureCone, side: THREE.DoubleSide});
			    var coneGeometry = new THREE.CylinderGeometry(1, 5, 15, 32);
			    var cone = new THREE.Mesh(coneGeometry, coneMaterial);
			    cone.position.set(Math.floor((Math.random() * 5000) + -2500), 7, Math.floor((Math.random() * 5000) + -2500));
			    collidableMeshList.push(cone);
			    scene.add( cone );
			}
			// car
			var objectLoader = new THREE.ObjectLoader();
			objectLoader.load("car2/camero-2010-low-poly.json", function ( obj ) {
			obj.scale.set(15, 15, 15);
			car = obj;
			car.position.x = -2000;
			car.position.z = 100;
			scene.add( car );
			} );
		}
		function animate(){
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			// renderer.shadowMap.enabled = true;
			  // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			if( car != null) {
			  update();
			  if(pressedUpDown == 1){
			    car.translateZ(moveDistance);
			    cube.translateZ(moveDistance);
			  }
			}
			
		}
		var pressedUpDown = 0;
		var delta = clock.getDelta();
		var moveDistance = 200 * delta;
		var throughFinish = 0;
		var start = 0;
		function update() {
		  delta = clock.getDelta();
		  var rotationAngle = Math.PI/2*delta;	
		
		  if(keyboard.pressed("W")){
		    pressedUpDown = 1;
		    moveDistance -=0.1;
		  }
		  if(keyboard.pressed("S")){
		    pressedUpDown = 1;
		    moveDistance += 0.1;
		  }
		  
		  var rotation_matrix = new THREE.Matrix4().identity();
		  if(keyboard.pressed("A")){
		    car.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);
		    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);
		  }
		  if(keyboard.pressed("D")){
		    car.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);
		    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);
		  }
		  
		  var relativeCameraOffset = new THREE.Vector3(0,5,15);
		  var cameraOffset = relativeCameraOffset.applyMatrix4(car.matrixWorld);
		  
		  var originPoint = cube.position.clone();
		  for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++) {		
		    var localVertex = cube.geometry.vertices[vertexIndex].clone();
		    var globalVertex = localVertex.applyMatrix4( cube.matrix );
		    var directionVector = globalVertex.sub( cube.position );
		
		    var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		    var collisionResults = ray.intersectObjects( collidableMeshList );
		    if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) {
		      	car.position.set(-2000, 7, 100);
			 	cube.position.set(-2000, 7, 100);
			 	throughFinish = 0;
		        alert ("You lose! Do not hit walls or cones! Restart!");
		      	location.reload();
			}
		    }
		    			crossFinish();
	
		  
		  camera.position.x = cameraOffset.x;
		  camera.position.y = cameraOffset.y;
		  camera.position.z = cameraOffset.z;
		  camera.lookAt(car.position);
		  
		}
		throughStart = 0;
		throughC1 = 0;
		throughC2 = 0;
		function crossFinish(){
			var originPoint1 = cube.position.clone();
			for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++) {		
		    var localVertex1 = cube.geometry.vertices[vertexIndex].clone();
		    var globalVertex1 = localVertex1.applyMatrix4( cube.matrix );
		    var directionVector1 = globalVertex1.sub( cube.position );
		    var ray1 = new THREE.Raycaster( originPoint1, directionVector1.clone().normalize() );
		    var collisionResults1 = ray1.intersectObjects( checkpoint1 );
		    if ( collisionResults1.length > 0 && collisionResults1[0].distance < directionVector1.length() ) {
		    	throughC1 = 1;
			}
		}
		for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++) {		
		    var localVertex2 = cube.geometry.vertices[vertexIndex].clone();
		    var globalVertex2 = localVertex2.applyMatrix4( cube.matrix );
		    var directionVector2 = globalVertex2.sub( cube.position );
		    var ray2 = new THREE.Raycaster( originPoint1, directionVector2.clone().normalize() );
		    var collisionResults2 = ray2.intersectObjects( checkpoint2 );
		    if ( collisionResults2.length > 0 && collisionResults2[0].distance < directionVector2.length() ) {
		    	throughC2 = 1;
			}
		}
		  for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++) {		
		    var localVertex3 = cube.geometry.vertices[vertexIndex].clone();
		    var globalVertex3 = localVertex3.applyMatrix4( cube.matrix );
		    var directionVector3 = globalVertex3.sub( cube.position );
		    var ray3 = new THREE.Raycaster( originPoint1, directionVector3.clone().normalize() );
		    var collisionResults3 = ray3.intersectObjects( finishline );
		    if ( collisionResults3.length > 0 && collisionResults3[0].distance < directionVector3.length() ) {
		    	if(throughC1 > 0 && throughC2 > 0){
		    		alert("You won!");
		    		location.reload();

		    	}
			}
		}
		}
		
		</script>
	</body>
</html>
