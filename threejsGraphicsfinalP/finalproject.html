<!doctype html>
<html lang="en">
	<head>
		<title>Final Project</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/keys.js"></script>
		<script src='js/THREEx.KeyboardState.js'></script>

		<script>
		var scene, camera, renderer, controls, container;
		var car;
		var clock = new THREE.Clock();
		var keyboard = new THREEx.KeyboardState();
		var collidableMeshList = [];

		
		init();
		animate();
			 
		function init() {
			scene = new THREE.Scene();
			var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
			var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH/SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			scene.add(camera);
			camera.lookAt(scene.position);

			//Renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            //lighting
            //var light = new THREE.PointLight(0xffffff, 1.5, 2000, 0);
            var light = new THREE.DirectionalLight(0xffffff, 1.75);
            light.position.set(-500, 500, -500);
            //light.position.set(0, 5, 0);
            scene.add(light);

            var aLight = new THREE.AmbientLight( 0x404040, 1 );
            scene.add( aLight );

            var sphereSize = 1;
            var pointLightHelper = new THREE.PointLightHelper( light, sphereSize );
            scene.add( pointLightHelper );

			// load a texture, set wrap mode to repeat
			var texture = new THREE.TextureLoader().load( "textures/racetrackEdit.png" );
			var textureSky = new THREE.TextureLoader().load("textures/cloudy.jpg");
			var textureCone = new THREE.TextureLoader().load("textures/cone.jpg");
			var textureWalls = new THREE.TextureLoader().load("textures/wall.jpg");
						

			//Skybox
			var skyBoxGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
			var skyBoxMaterial = new THREE.MeshBasicMaterial({map: textureSky, side: THREE.BackSide});
			var sky = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
			scene.add(sky);

			//Plane Geometry
			var geometry = new THREE.PlaneGeometry( 5000, 5000, 10, 10);
            var material = new THREE.MeshPhongMaterial( { map: texture, side: THREE.DoubleSide } );
			var plane = new THREE.Mesh( geometry, material );
			plane.position.y = -0.5;
			plane.rotation.x = Math.PI/2;
			scene.add( plane );	
			
			//east wall
			for(i = -26; i <26; i++){
			  var wallEastGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallEastMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallEast = new THREE.Mesh(wallEastGeometry, wallEastMaterial);
			   wallEast.position.set(5000/2, 7, i *100);
			  wallEast.rotation.y = Math.PI/2;
			  scene.add(wallEast);
			  collidableMeshList.push(wallEast);

			}
			
			//west wall
			for(i = -26; i <26; i++){
			  var wallWestGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallWestMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallWest = new THREE.Mesh(wallWestGeometry, wallWestMaterial);
			   wallWest.position.set(-5000/2, 7, i *100);
			  wallWest.rotation.y = Math.PI/2;
			  collidableMeshList.push(wallWest);
			  scene.add(wallWest);
			}
			
			//North wall
			for(i = -26; i <26; i++){
			  var wallNorthGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallNorthMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallNorth = new THREE.Mesh(wallNorthGeometry, wallNorthMaterial);
			   wallNorth.position.set(i *100, 7, -5000/2);
			  scene.add(wallNorth);
			}
			//North wall
			for(i = -26; i <26; i++){
			  var wallSouthGeometry = new THREE.CubeGeometry(100, 100, 5);
			  var wallSouthMaterial = new THREE.MeshPhongMaterial({map: textureWalls, side: THREE.DoubleSide});
			  var wallSouth = new THREE.Mesh(wallSouthGeometry, wallSouthMaterial);
			   wallSouth.position.set(i *100, 7, 5000/2);
			   collidableMeshList.push(wallSouth);
			  scene.add(wallSouth);
			}
			
			//car/cube
             var cubeMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, side: THREE.DoubleSide});
			 var cubeGeometry = new THREE.CubeGeometry(27, 27, 27, 1, 1, 1, cubeMaterial);
			 cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
			 cube.position.set(0, 7, 0);
			 cube.material.transparent = true;
			 cube.material.opacity = 0;
			 scene.add(cube);

			//cones
			for(i = 0; i < 500; i++) {
			    // var coneMaterial = new THREE.MeshPhongMaterial({color: 0xff6600, side: THREE.DoubleSide});
                var coneMaterial = new THREE.MeshPhongMaterial({map: textureCone, side: THREE.DoubleSide});
				var coneGeometry = new THREE.CylinderGeometry(1, 5, 15, 32);
			    var cone = new THREE.Mesh(coneGeometry, coneMaterial);
			    cone.position.set(Math.floor((Math.random() * 5000) + -2500), 7, Math.floor((Math.random() * 5000) + -2500));
			   collidableMeshList.push(cone);
			   scene.add( cone );
			}

            // car
            var objectLoader = new THREE.ObjectLoader();
            objectLoader.load("car2/camero-2010-low-poly.json", function ( obj ) {
                obj.scale.set(15, 15, 15);
                car = obj;

                scene.add( car );
            } );
		}

		function animate(){
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
            // renderer.shadowMap.enabled = true;
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			if( car != null) {
			update();
			 if(pressedUpDown == 1){
		    car.translateZ(moveDistance);
		    cube.translateZ(moveDistance);
		  }
			}
			

		}
		var pressedUpDown = 0;
		
		var delta = clock.getDelta();
		var moveDistance = 200 * delta;

		function update() {
		  delta = clock.getDelta();
		  var rotationAngle = Math.PI/2*delta;	
		


		  if(keyboard.pressed("W")){
		    pressedUpDown = 1;
		    moveDistance -=0.1;
		    //car.translateZ(-moveDistance);
		  }
		  if(keyboard.pressed("S")){
		    pressedUpDown = 1;
		    moveDistance += 0.1;
		   // car.translateZ(moveDistance);
		  }

		  
		  var rotation_matrix = new THREE.Matrix4().identity();
		  if(keyboard.pressed("A")){
		    car.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);
		    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotationAngle);

		  }

		  if(keyboard.pressed("D")){
		    car.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);
		    cube.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotationAngle);
		  }
		  


		  var relativeCameraOffset = new THREE.Vector3(0,5,15);
		  var cameraOffset = relativeCameraOffset.applyMatrix4(car.matrixWorld);
		  
		  var originPoint = cube.position.clone();
		  for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++) {		
		    var localVertex = cube.geometry.vertices[vertexIndex].clone();
		    var globalVertex = localVertex.applyMatrix4( cube.matrix );
		    var directionVector = globalVertex.sub( cube.position );
		
		    var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		    var collisionResults = ray.intersectObjects( collidableMeshList );
		    if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
		      moveDistance = 0;
		    }	
		  
		  camera.position.x = cameraOffset.x;
		  camera.position.y = cameraOffset.y;
		  camera.position.z = cameraOffset.z;
		  camera.lookAt(car.position);
		  

		}
		
		</script>
	</body>
</html>
