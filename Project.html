<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8"/>
    <title>Final Project</title>
    <meta name="generator" content="BBEdit 10.5" />
    
<script type="text/javascript" src="glMatrix_util.js"></script>
<script type="text/javascript" src="keys.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;
  varying vec2 vTextureCoord;
  varying vec3 vLightWeight;
  uniform sampler2D uSampler;
  void main(void){
    vec4 tx_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;
  attribute vec3 aVertexNormal;
  
  uniform mat4 uniformModelViewMatrix;
  uniform mat4 uniformProjectionMatrix
  uniform sampler2D uSampler;
  uniform mat3 uNormalMatrix;
  uniform vec3 uAmbientColor;
  uniform vec3 uLightDirection;
  uniform vec3 uDirectionalColor;
  
  varying vec3 vLightWeight;
  varying vec3 vNormalVertexPosition;
  varying vec4 clrVec;
  varying nClrVec;
  varying vec2 vTextureCoord;
  void main(void){
      /*nVertexPosition[0] = aVertexPosition[0];
        nVertexPosition[1] = 0.5;
        nVertexPosition[2] = aVertexPosition[2];
        vTextureCoord = aTextureCoord;
        clrVec = texture2D(uSampler,vTextureCoord);
        nclrVec = normalize(clrVec);
        nVertexPosition[1] = nclrVec[0]*nclrVec[0] + nclrVec[1]*nclrVec[1]+nclrVec[2]*nclrVec[2];
        gl_Position = uPMatrix * uMVMatrix * vec4(nVertexPosition, 1.0);*/
        
    vec3 testNorm = aVertexNormal;
    vec3 transformedNormal = uNormalMatrix *  aVertexNormal;
    float directionalLightWeight = max(dot(tranformedNormal, uLightDirection));
    vLightWeight = uAmbientColor + uDirectionalColor * directionalLightWeight;

  }
</script>

<script><!--func-->

var gl;
function initWGLContext(name){
  gl = null;
  var canvas = document.getElementById(name);
  try{
    gl = canvas.getContext("webgl") || canval.getContext("experimental-webgl");
  }catch(e){}
  
  if(!gl){
    alert("Unable to initialize WebGL. Your browser may not support it.");
    gl = null;
  }
  gl.viewportWidth = canvas.width;
  gl.viewportHeight = canvas.height;
  return gl;
}

function initScene(){
  var gl = initWGLContext("hellowebgl");
  if(!gl){
    return;
  }
  return gl;
}

function getShader(gl, id){
  var shaderSc = document.getElementById(id);
  if(!shaderSc){
    return null;
  }
  var str = "";
  var child = shaderSc.firstChild;
  while(child){
    if(child.nodeType===3){
      str+=child.textContent;
    }
    child = child.nextSibling;
  }
  
  var shader;
  if(shaderSc.type === "x-shader/x-fragment"){
    shader = gl.createShader(gl.FRAGMENT_SHADER);
  }else if(shaderSc.type === "x-shader/x-vertex"){
    shader = gl.createShader(gl.VERTEX_SHADER);
  }else{
    return null
  }
  
  gl.shaderSource(shader, str);
  gl.compileShader(shader);
  
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
    alert(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

var sProg;
function initShader(){
  var fShader = getShader(gl, "shader-fs");
  var vShader = getShader(gl, "shader-vs");
  sProg = gl.createProgram();
  
  gl.attachShader(sProg, vShader);
  gl.attachShader(sProg, fShader);
  gl.linkProgram(sProg);
  
  if(!gl.getProgramParameter(sProg, gl.LINK_STATUS)){
    alert("Couldn't initialize shaders");
  }
  
  gl.useProgram(sProg);
  
  sProg.vertexPositionAttribute = gl.getAttribLocation(sProg, "aVertexPosition");
  gl.enableVertexAttribArray(sProg.vertexPositionAttribute);
  sProg.vertexNormalAtribute = gl.getAttribLocation(sProg, "aVertexNormal");
  gl.enableVertexAttribArray(sProg.vertexNormalAtribute);
  sProg.vertexPositionAttribute = gl.getAttribLocation(sProg, "aTextureCoord");
  gl.enableVertexAttribArray(sProg.textureCoordAttribute);
  sProg.projectionMatrixUniform = gl.getUniformLocation(sProg, "uniformProjectionMatrix");
  sProg.modelViewMatrixUniform = gl.getUniformLocation(sProg, "uniformModelViewMatrix");
  sProg.samplerUniform = gl.getUniformLocation(sProg, "uSampler");
  sProg.tnMatrixUniform = gl.getUniformLocation(sProg, "uNormalMatrix");
  sProg.ambientColorUniform = gl.getUniformLocation(sProg, "uAmbientColor");
  sProg.lightingDirectionUniform = gl.getUniformLocation(sProg, "uLightDirection");
  sProg.directionalColorUniform = gl.getUniformLocation(sProg, "uDirectionalColor");
}

var modelViewMatrix = mat4.create();
var modelViewStack = [];
var projectionMatrix = mat4.create();

function modelViewPushMat(){
  var copy = mat4.create();
  mat4.set(modelViewMatrix, copy);
  modelViewStack.push(copy);
}

function  modelViewPopMat(){
  if(modelViewStack.length === 0){
    throw "Invalid popMatrix!";
  }
  modelViewMatrix = modelViewStack.pop();
}

function setMatUniforms(){
  gl.uniformMatrix4fv(sProg.projectionMatrixUniform, false, projectionMatrix);
  gl.uniformMatrix4fv(sProg.modelViewMatrixUniform, false, modelViewMatrix);
  var normMatrix = mat3.create();
  mat4.toInverseMat3(modelViewMatrix, normMatrix);
  gl.uniformMatrix3fv(sProg.tnMatrixUniform, false, normMatrix);
}

var vertexPositionBuff;
var vertexTextureCoordBuff;
var vertexIndexBuff;
var normalBuff;
function makePlaneGeometry(){
  vertexPositionBuff = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuff);
  verticies = [];
  normalVerticies = [];
  
  for(i=0; i < 100; i++){
    for(j=0; j<100; j++){
      vertices[0 + j*3 + i*100*3] = (j*1.0)/50.0 -1.0;
      vertices[1 + j*3 + i*100*3] = 0.0;
      vertices[2 + j*3 + i*100*3] = (i*1.0)/50.0 -1.0; 

      nvertices[0 + j*3 + i*100*3] = 0.0;
      nvertices[1 + j*3 + i*100*3] = 1.0;
      nvertices[2 + j*3 + i*100*3] = 0.0; 
    }
  }
  
  gl.bufferData(gl.ARRAY_BUFFER, new Float32ARRAY(vertices), gl.STATIC_DRAW);
  vertexPositionBuff.itemSize = 3;
  vertexPositionBuff.numItems = 10000;
  
  normalBuff = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuff);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32ARRAY(normalVerticies), gl.STATIC_DRAW);
  normalBuff.itemSize = 3;
  normalBuff.numItems = 10000;
  
  vertexTextureCoordBuff = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuff);
  textureCoords = [];
  tC = 0;
  for ( i=0; i < 100; i++) {
    for (j = 0; j < 100; j++) {
      textureCoords[tC++] = 0.0 + (j*1.0)/100.0;
      textureCoords[tC++] = 0.0 + (i*1.0)/100.0;
    }
  }
  
  gl.bufferData(gl.ARRAY_BUFFER, new Float32ARRAY(textureCoords), gl.STATIC_DRAW);
  vertexTextureCoordBuff.itemSize = 2;
  vertexTextureCoordBuff.numItems = tC/2;
  
  vertexIndexBuff = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuff);
  vertexIndicies = [];
  tvi = 0;
  for ( i=0; i < 99; i++){
    for (j = 0; j < 99; j++){
      terVertexIndices[tvi++] = 0+j+i*100;
      terVertexIndices[tvi++] = 1+j+i*100;
      terVertexIndices[tvi++] = 0+j+(i+1)*100;
      terVertexIndices[tvi++] = 0+j+(i+1)*100;
      terVertexIndices[tvi++] = 1+j+(i+1)*100;
      terVertexIndices[tvi++] = 1+j+i*100;
    }
  }
  
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndicies), gl.STATIC_DRAW);
  vertexIndexBuff.itemSize = 1;
  vertexIndexBuff.numItems = tvi;
}

function initGeometry(){
  makePlaneGeometry();
}

var texture;
function initTexture(){
  texture = gl.createTexture();
  texture.image = new Image();
  texture.image.onload = function(){
    handleLoadedTexture(texture)
  }
  texture.image.src = "reacetrackEdit.png";
}

function handleLoadedTexture(textures){
  gl.bindTexture(gl.TEXTURE_2D, textures);
  gl.pixelStorei(gl.INPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures.image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function startWebGL(){
  var gl = initGLScene();
  initShaders();
  initGeometry();
  initTexture();
  
  var canvas = document.getElementById("hellowebgl");
  
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.enable(gl.DEPTH_TEST);
  Frames();
}

function bindBuffers(){
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuff);
  gl.vertexAttribPointer(sProg.vertexPositionAttribute, vertexPositionBuff.itemSize, gl.FLOAT, false, 0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuff);
  gl.vertexAttribPointer(sProg.vertexNormalAtribute, normalBuff.itemSize, gl.FLOAT, false, 0,0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniforml1i(sProg.samplerUniform, 0);
  gl.uniforml1i(sProg.samplerUniform, 0);
}

var xRotation;
var yRotation;
var zRotation;
function drawScene(){
  gl.viewport(0,0,gl.viewportWidth,gl.viewportHeight);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  mat4.perspective(45, gl.viewportWidth/fl.viewportHeigth, 0.1, 100.0, projectionMatrix);
  mat4.indentity(modelViewMatrix);
  mat4.translate(modelViewMatrix, [0.0, 0.0, -5.0]);
  mat4.multiply(modelViewMatrix, objectRotationMatrix);
  
  bindBuffers();
  
  gl.uniform3f(sProg.ambientColorUniform, 0.4, 0.0, 0.5);
  
  var lightingDirection = [0.0, 0.0, 0.0];
  
  var adjustedLD = vec3.create();
  vec3.normalize(lightingDirection, adjustedLD);
  vec3.scale(adjustedLD, -1);
  
  gl.uniform3f(0.0, 0.5, 0.0);
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuff);
  setMatUniforms();
  gl.drawElements(gl.TRIANGLES, vertexIndexBuff.numItems, gl.UNSIGNED_SHORT, 0);
}
        
var lastTime = 0;

function animate(){
  //make move forward?
}

function Frames(){
  requestAnimFrame(Frames);
  drawScene();
}

</script>
  
  
    
</head>
<body>
    <h1>Final Project</h1>

    <!-- embed the HTML5 Canvas Drawing object on the page.-->
    <!-- Name the canvas 'projectCanvas' for the javascript code. -->
    <canvas id="projectCanvas" width=800 height=800>
        If you're seeing this your web browser doesn't support the &lt;canvas>&gt; element. Ouch!
    </canvas>
</body>
</html>